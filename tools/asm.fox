format ELF64 executable
entry start

; --- CONSTANTS ---
sys_read    = 0
sys_write   = 1
sys_open    = 2
sys_close   = 3
sys_fstat   = 5
sys_mmap    = 9
sys_exit    = 60

O_RDONLY    = 0
O_WRONLY    = 1
O_CREAT     = 64
O_TRUNC     = 512

PROT_READ   = 1
PROT_WRITE  = 2
MAP_PRIVATE = 2
MAP_ANONYMOUS = 32

S_IRWXU     = 448 ; 0700 octal

; --- CODE ---
start:
    pop rcx
    cmp rcx, 2
    jl usage

    pop rdi
    pop rdi
    mov [input_filename], rdi

    ; Open Input File
    mov rax, sys_open
    mov rdi, [input_filename]
    mov rsi, O_RDONLY
    mov rdx, 0
    syscall

    cmp rax, 0
    jl error_open
    mov [input_fd], rax

    ; Get File Size
    mov rax, sys_fstat
    mov rdi, [input_fd]
    lea rsi, [stat_buf]
    syscall

    mov rax, [stat_buf + 48]
    mov [input_size], rax

    ; Map Input File
    mov rax, sys_mmap
    mov rdi, 0
    mov rsi, [input_size]
    mov rdx, PROT_READ
    mov r10, MAP_PRIVATE
    mov r8, [input_fd]
    mov r9, 0
    syscall

    cmp rax, -1
    je error_mmap
    mov [source_ptr], rax

    ; Calculate Source End
    add rax, [input_size]
    mov [source_end], rax

    ; Initialize Output Pointer
    lea rax, [output_buffer]
    mov [output_ptr], rax

    ; Write Header to Output Buffer
    mov rdi, [output_ptr]
    mov rax, 0x584F464C454F5A56 ; "VZOELFOX" in little endian (XOFLEOZV)
    mov [rdi], rax
    add qword [output_ptr], 8

    ; --- MAIN LOOP ---
.assemble_loop:
    call get_token
    cmp rax, 0
    je .finish

    ; Hash the token
    lea rdi, [token_buffer]
    mov rsi, rax
    call fnv1a_hash

    ; Lookup
    call lookup_instruction
    cmp rdi, 0
    je .unknown_token

    ; Found! Encode it.
    ; rdi points to mnemonic string.
    ; Skip string to get metadata.
    push rdi
    call strlen
    pop rdi

    ; Metadata starts at rdi + rax + 1
    lea rsi, [rdi + rax + 1] ; rsi points to Flags

    ; Read Flags (Byte)
    lodsb
    ; TODO: Handle flags (REX.W, RegInOp)

    ; Read Opcode Len (Byte)
    xor rcx, rcx
    lodsb
    mov cl, al ; cl = opcode len

    ; Read Opcode Bytes (3 Bytes) and Write to Output
    xor rdx, rdx
.write_opcode:
    cmp rdx, rcx
    je .opcode_done
    lodsb
    mov rbx, [output_ptr]
    mov [rbx], al
    inc qword [output_ptr]
    inc rdx
    jmp .write_opcode

.opcode_done:
    ; Read ModRM Type
    lodsb
    ; TODO: Handle ModRM

    jmp .assemble_loop

.unknown_token:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_unknown]
    mov rdx, 22
    syscall

    ; Print the token that failed
    lea rdi, [token_buffer]
    call strlen
    mov rdx, rax
    lea rsi, [token_buffer]
    mov rax, sys_write
    mov rdi, 1
    syscall

    mov rax, sys_write
    mov rdi, 1
    lea rsi, [newline]
    mov rdx, 1
    syscall

    jmp exit

.finish:
    ; Create Output File
    mov rax, sys_open
    lea rdi, [output_filename]
    mov rsi, O_CREAT + O_WRONLY + O_TRUNC
    mov rdx, S_IRWXU
    syscall

    cmp rax, 0
    jl error_create
    mov [output_fd], rax

    ; Write Buffer to File
    mov rax, sys_write
    mov rdi, [output_fd]
    lea rsi, [output_buffer]
    mov rdx, [output_ptr]
    sub rdx, rsi ; Length = output_ptr - output_buffer
    syscall

    ; Close Output
    mov rax, sys_close
    mov rdi, [output_fd]
    syscall

    ; Success Exit
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_done]
    mov rdx, 14
    syscall

    mov rax, sys_exit
    xor rdi, rdi
    syscall

usage:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_usage]
    mov rdx, 20
    syscall
    jmp exit

error_open:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err]
    mov rdx, 16
    syscall
    jmp exit

error_mmap:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err]
    mov rdx, 16
    syscall
    jmp exit

error_create:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err]
    mov rdx, 16
    syscall
    jmp exit

exit:
    mov rax, sys_exit
    mov rdi, 1
    syscall

; --- ROUTINES ---

get_token:
    ; Output: token_buffer filled, rax = length
    ; If EOF, rax = 0

    xor rcx, rcx ; token length
    lea rdi, [token_buffer]

.skip_whitespace:
    mov rsi, [source_ptr]
    cmp rsi, [source_end]
    jae .eof

    mov al, [rsi]
    inc qword [source_ptr]

    ; Check whitespace
    cmp al, ' '
    je .skip_whitespace
    cmp al, 9 ; tab
    je .skip_whitespace
    cmp al, 10 ; newline
    je .skip_whitespace
    cmp al, 13 ; CR
    je .skip_whitespace

    ; Check comment
    cmp al, ';'
    je .skip_comment

    ; Found start of token
    jmp .read_token_char

.skip_comment:
    mov rsi, [source_ptr]
    cmp rsi, [source_end]
    jae .eof

    mov al, [rsi]
    inc qword [source_ptr]

    cmp al, 10 ; newline ends comment
    je .skip_whitespace
    jmp .skip_comment

.read_token_loop:
    mov rsi, [source_ptr]
    cmp rsi, [source_end]
    jae .token_done

    mov al, [rsi]
    ; Check delimiters
    cmp al, ' '
    je .token_done
    cmp al, 9
    je .token_done
    cmp al, 10
    je .token_done
    cmp al, 13
    je .token_done
    cmp al, ';'
    je .token_done_rewind ; Rewind so next call sees comment
    cmp al, ','
    je .token_single_char ; Comma is a separate token?

    inc qword [source_ptr]

.read_token_char:
    mov [rdi + rcx], al
    inc rcx
    cmp rcx, 255
    jge .token_done ; safety
    jmp .read_token_loop

.token_done_rewind:
    ; We hit a char that shouldn't be consumed (like ';')
    ; source_ptr is NOT incremented for it yet (in read_token_loop check)
    jmp .token_done

.token_single_char:
    ; If we hit a comma, and we have accumulated token, stop.
    ; If we haven't (rcx=0), then consume comma as the token.
    cmp rcx, 0
    jne .token_done ; Return current token, leave comma for next

    ; Emit comma as token
    inc qword [source_ptr]
    mov [rdi], al
    mov rcx, 1
    jmp .token_done

.token_done:
    mov byte [rdi + rcx], 0 ; null terminate
    mov rax, rcx
    ret

.eof:
    mov rax, 0
    ret

strlen:
    ; Input: rdi (str)
    ; Output: rax (len)
    xor rax, rax
.loop:
    cmp byte [rdi + rax], 0
    je .done
    inc rax
    jmp .loop
.done:
    ret

fnv1a_hash:
    ; Input: rdi (ptr to string), rsi (length)
    ; Output: rax (hash)
    mov rax, 0xcbf29ce484222325
    mov r8, 0x100000001b3
    xor rcx, rcx
.loop:
    cmp rcx, rsi
    je .done
    xor r9, r9
    mov r9b, [rdi + rcx]
    xor rax, r9
    mul r8
    inc rcx
    jmp .loop
.done:
    ret

lookup_instruction:
    ; Input: rax (hash)
    ; Output: rdi (ptr to metadata) or 0 if not found

    push rbx
    mov rbx, rax

    xor rdx, rdx
    mov rcx, VZOEL_TABLE_SIZE
    div rcx

    mov rcx, rdx ; index
    mov rsi, rdx ; start index

.probe:
    mov r8, [vzoel_table_keys + rcx*8]
    cmp r8, 0
    je .not_found

    cmp r8, rbx
    je .found

    inc rcx
    and rcx, VZOEL_TABLE_SIZE - 1

    cmp rcx, rsi
    je .not_found
    jmp .probe

.found:
    mov rdi, [vzoel_table_values + rcx*8]
    pop rbx
    ret

.not_found:
    xor rdi, rdi
    pop rbx
    ret

; --- DATA ---
input_filename dq 0
input_fd dq 0
input_size dq 0
source_ptr dq 0
source_end dq 0
output_ptr dq 0
output_fd dq 0

msg_usage db "Usage: asm.fox <in>", 10, 0
msg_err db "Error detected.", 10, 0
msg_unknown db "Error: Unknown token: ", 0
msg_done db "Done. out.morph", 10, 0
newline db 10, 0
output_filename db "out.morph", 0

stat_buf:
    rb 144

segment readable writeable
output_buffer: rb 1048576 ; 1MB
token_buffer: rb 256

include '../brainlib/vzoel_table.fox'
