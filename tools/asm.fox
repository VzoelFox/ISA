format ELF64 executable
entry start

; --- CONSTANTS ---
sys_read    = 0
sys_write   = 1
sys_open    = 2
sys_close   = 3
sys_fstat   = 5
sys_mmap    = 9
sys_exit    = 60

O_RDONLY    = 0
O_WRONLY    = 1
O_CREAT     = 64
O_TRUNC     = 512

PROT_READ   = 1
PROT_WRITE  = 2
MAP_PRIVATE = 2
MAP_ANONYMOUS = 32

S_IRWXU     = 448 ; 0700 octal

; --- CODE ---
start:
    pop rcx
    cmp rcx, 2
    jl usage

    pop rdi
    pop rdi
    mov [input_filename], rdi

    ; Open Input File
    mov rax, sys_open
    mov rdi, [input_filename]
    mov rsi, O_RDONLY
    mov rdx, 0
    syscall

    cmp rax, 0
    jl error_open
    mov [input_fd], rax

    ; Get File Size
    mov rax, sys_fstat
    mov rdi, [input_fd]
    lea rsi, [stat_buf]
    syscall

    mov rax, [stat_buf + 48]
    mov [input_size], rax

    ; Map Input File
    mov rax, sys_mmap
    mov rdi, 0
    mov rsi, [input_size]
    mov rdx, PROT_READ
    mov r10, MAP_PRIVATE
    mov r8, [input_fd]
    mov r9, 0
    syscall

    cmp rax, 0
    jl error_mmap
    mov [source_ptr], rax
    mov [start_ptr], rax ; Save start for rewind

    ; Calculate Source End
    add rax, [input_size]
    mov [source_end], rax

    ; Initialize Output Pointer
    lea rax, [output_buffer]
    mov [output_ptr], rax

    ; Write Header to Output Buffer
    mov rdi, [output_ptr]
    mov rax, 0x584F464C454F5A56 ; "VZOELFOX" in little endian (XOFLEOZV)
    mov [rdi], rax
    add qword [output_ptr], 8

    mov qword [pass_count], 1

.pass_start:
    ; Reset current_offset
    mov qword [current_offset], 0

    ; --- MAIN LOOP ---
.assemble_loop:
    call get_token
    cmp rax, 0
    je .pass_done

    ; Check for Label Definition
    push rax ; Save token length
    call try_parse_label
    mov rbx, rax
    pop rax ; Restore token length
    cmp rbx, 1
    je .assemble_loop ; Label handled, continue

    ; Check for Directives
    push rax ; Save token length
    call try_parse_directive
    mov rbx, rax ; Save result
    pop rax ; Restore token length
    cmp rbx, 1
    je .assemble_loop

    ; Check for Structure Keywords
    push rax
    call try_parse_structure
    mov rbx, rax
    pop rax
    cmp rbx, 1
    je .assemble_loop

    ; Hash the token
    lea rdi, [token_buffer]
    mov rsi, rax
    call fnv1a_hash

    ; Lookup
    call lookup_instruction
    cmp rdi, 0
    je .unknown_token

    ; Found! Encode it.
    ; rdi points to mnemonic string.
    ; Skip string to get metadata.
    push rdi
    call strlen
    pop rdi

    ; Metadata starts at rdi + rax + 1
    lea rsi, [rdi + rax + 1] ; rsi points to Flags

    ; Read Flags (Byte)
    lodsb
    mov r12, rax ; Save Flags in r12 (callee-saved, safe?)
    ; Flags: 1=REX.W, 2=RegInOp, 4=Imm8, 8=Imm32
    ; We will also use r13 for calculated REX byte
    mov r13, 0
    test r12, 1
    jz .no_rex_w
    or r13, 0x48 ; REX.W
.no_rex_w:

    ; Read Opcode Len (Byte)
    xor rcx, rcx
    lodsb
    mov cl, al ; cl = opcode len

    ; Read Opcode Bytes (3 Bytes) and SAVE to buffer (opcode_buf)
    ; We cannot write it yet because REX prefix (if any) must come before Opcode.
    ; But REX is determined by operands, which are parsed AFTER opcode lookup.
    ; So:
    ; 1. Save Opcode to temporary buffer.
    ; 2. Parse Operands -> Determine REX.
    ; 3. Write REX (if any).
    ; 4. Write Opcode.
    ; 5. Write ModRM.

    mov [opcode_len], rcx
    xor rdx, rdx
    lea rdi, [opcode_buf]
.save_opcode:
    cmp rdx, rcx
    je .skip_padding
    lodsb
    mov [rdi + rdx], al
    inc rdx
    jmp .save_opcode

.skip_padding:
    ; We read 'rcx' bytes. The field is 3 bytes wide.
    ; We need to skip (3 - rcx) bytes.
    mov rbx, 3
    sub rbx, rcx
    add rsi, rbx

.opcode_done:
    ; Read ModRM Type
    lodsb
    cmp al, 0
    je .check_immediates

    ; If al != 0, we need to parse operands.
    ; al = 1: rm,reg
    ; al = 2: reg,rm
    ; al >= 0x10: Extension (rm with opcode ext)

    cmp al, 0x10
    jae .modrm_extension

    push rax ; Save ModRM Type

    ; Parse First Operand (RM if type 1, REG if type 2)
    call get_token ; Token 1 (e.g. rax)
    call parse_register
    mov r8, rax ; r8 = First Register ID
    mov r10, rdx ; r10 = Is Memory?

    ; Handle REX bits for First Operand
    cmp r8, 8
    jl .first_op_low
    or r13, 0x40 ; REX prefix needed
    ; If type 1 (rm,reg), First is RM -> REX.B
    ; If type 2 (reg,rm), First is REG -> REX.R
    ; We'll adjust later or specific bits now?
    ; Let's store raw ID in r8/r9 and handle bits at ModRM construction
.first_op_low:

    ; Expect Comma
    call get_token
    ; TODO: Check if it is comma

    ; Parse Second Operand
    call get_token ; Token 2 (e.g. rbx)
    call parse_register
    mov r9, rax ; r9 = Second Register ID
    mov r11, rdx ; r11 = Is Memory?

    ; Handle REX bits for Second Operand
    cmp r9, 8
    jl .second_op_low
    or r13, 0x40 ; REX prefix needed
.second_op_low:

    pop rax ; Restore ModRM Type

    ; Construct ModRM Byte
    ; ModRM = Mod(2) | Reg(3) | RM(3)
    ; Mod = 11b (0xC0) for Register Direct Mode

    cmp al, 1 ; rm,reg
    je .modrm_rm_reg
    cmp al, 4 ; mem,reg (same as rm,reg but requires mem)
    je .modrm_rm_reg

    ; .modrm_reg_rm (Type 2) or Type 3 (reg,mem)
    ; First op (r8) is REG (ModRM.reg), Second op (r9) is RM (ModRM.rm)
    ; r10 indicates if First Op is Memory (Not allowed for Type 2 REG role)
    ; r11 indicates if Second Op is Memory

    ; REG cannot be memory.
    ; RM can be memory.

    ; Check REX.R (for REG=r8)
    test r8, 8
    jz .no_rex_r_2
    or r13, 4 ; REX.R
.no_rex_r_2:
    ; Check REX.B (for RM=r9)
    test r9, 8
    jz .no_rex_b_2
    or r13, 1 ; REX.B
.no_rex_b_2:

    mov rbx, r8
    and rbx, 7 ; Mask to 0-7
    shl rbx, 3 ; REG << 3

    ; ModRM Mod Field
    ; If Memory (r11=1), Mod=00 (Direct). Else Mod=11 (Register)

    cmp r11, 1
    jne .mod_reg_2

    ; Memory Mode (Mod=00)
    ; Check for SIB requirement (RM=4/RSP or RM=12/R12)
    mov rcx, r9
    and rcx, 7
    cmp rcx, 4 ; RSP/R12 maps to 4 in ModRM.rm
    jne .no_sib_2

    ; SIB Required
    ; We set RM=4 in ModRM (which signals SIB follows)
    ; Then we write SIB byte.
    ; SIB: ss ii bbb
    ; For [rsp], scale=0, index=4 (none), base=4 (rsp). -> 24h
    ; For [r12], scale=0, index=4 (none), base=4 (r12). -> 24h
    ; Wait, r12 is base=12? No, base is 3 bits. r12&7 = 4.

    ; For now, simplistic SIB for [rsp] or [r12]
    ; SIB byte = 0x24 (Scale=0, Index=4/None, Base=4/RSP)
    ; Save SIB byte to write later?
    ; We need a place to store SIB. Let's use r14.
    mov r14, 0x24
    or r13, 0x100 ; Flag bit 8 of r13 (REX/Flags) to indicate SIB present

.no_sib_2:
    jmp .modrm_mem_2_finish

.mod_reg_2:
    or rbx, 0xC0 ; Mod=11
    mov rcx, r9
    and rcx, 7
    or rbx, rcx ; OR RM
    jmp .write_modrm

.modrm_mem_2_finish:
    mov rax, [mod_type]
    shl rax, 6
    or rbx, rax
    or rbx, rcx
    jmp .write_modrm

.modrm_rm_reg:
    ; First op (r8) is RM (ModRM.rm), Second op (r9) is REG (ModRM.reg)
    ; r10 = First Op Memory (RM)

    ; Check REX.R (for REG=r9)
    test r9, 8
    jz .no_rex_r_1
    or r13, 4 ; REX.R
.no_rex_r_1:
    ; Check REX.B (for RM=r8)
    test r8, 8
    jz .no_rex_b_1
    or r13, 1 ; REX.B
.no_rex_b_1:

    mov rbx, r9
    and rbx, 7
    shl rbx, 3 ; REG << 3

    ; Mod Field
    cmp r10, 1
    jne .mod_reg_1

    ; Memory Mode (Mod=00)
    mov rcx, r8
    and rcx, 7
    cmp rcx, 4 ; RSP/R12
    jne .no_sib_1

    ; SIB Required for [rsp]
    mov r14, 0x24
    or r13, 0x100 ; SIB flag

.no_sib_1:
    jmp .modrm_mem_1_finish

.modrm_mem_1_finish:
    mov rax, [mod_type]
    shl rax, 6
    or rbx, rax
    or rbx, rcx
    jmp .write_modrm

.mod_reg_1:
    or rbx, 0xC0 ; Mod=11
    mov rcx, r8
    and rcx, 7
    or rbx, rcx ; OR RM
    jmp .write_modrm

.modrm_extension:
    ; al contains 0x10 + Ext
    sub al, 0x10
    mov rdx, rax ; rdx = Extension (Reg field)

    ; Parse One Operand (RM)
    call get_token
    call parse_register
    mov r8, rax ; r8 = RM
    mov r10, rdx ; r10 = Is Memory?

    ; Check REX.B (for RM=r8)
    test r8, 8
    jz .no_rex_b_ext
    or r13, 0x40 ; Ensure REX prefix present (might not be if no REX.W)
    or r13, 1 ; REX.B
.no_rex_b_ext:

    ; Build ModRM
    mov rbx, rdx
    shl rbx, 3

    cmp r10, 1
    jne .mod_reg_ext

    ; Memory Mode (Mod=00)
    ; Check for SIB requirement (RM=4/RSP or RM=12/R12)
    mov rcx, r8
    and rcx, 7
    cmp rcx, 4
    jne .no_sib_ext

    ; SIB Required
    mov r14, 0x24
    or r13, 0x100

.no_sib_ext:
    jmp .modrm_mem_ext_finish

.modrm_mem_ext_finish:
    mov rax, [mod_type]
    shl rax, 6
    or rbx, rax
    or rbx, rcx
    jmp .write_modrm

.mod_reg_ext:
    or rbx, 0xC0 ; Mod=11
    mov rcx, r8
    and rcx, 7
    or rbx, rcx

.write_modrm:
    ; 1. Write REX prefix if needed (r13 != 0)
    cmp r13, 0
    je .no_rex_byte

    cmp qword [pass_count], 2
    jne .skip_write_rex

    call check_buffer_overflow
    mov rax, r13
    mov rcx, [output_ptr]
    mov [rcx], al
    inc qword [output_ptr]

.skip_write_rex:
    inc qword [current_offset]

.no_rex_byte:

    ; 2. Write Opcode (from opcode_buf)
    mov rcx, [opcode_len]
    xor rdx, rdx
    lea rdi, [opcode_buf]
.loop_write_op:
    cmp rdx, rcx
    je .done_write_op

    cmp qword [pass_count], 2
    jne .skip_write_op_delayed

    call check_buffer_overflow
    mov al, [rdi + rdx]
    mov r8, [output_ptr]
    mov [r8], al
    inc qword [output_ptr]

.skip_write_op_delayed:
    inc qword [current_offset]
    inc rdx
    jmp .loop_write_op
.done_write_op:

    ; 3. Write ModRM (in rbx)
    mov rax, rbx

    cmp qword [pass_count], 2
    jne .skip_write_modrm

    call check_buffer_overflow
    mov rbx, [output_ptr]
    mov [rbx], al
    inc qword [output_ptr]

.skip_write_modrm:
    inc qword [current_offset]

    ; 4. Write SIB (if r13 bit 8 is set)
    test r13, 0x100
    jz .no_sib_byte

    cmp qword [pass_count], 2
    jne .skip_write_sib

    call check_buffer_overflow
    mov rax, r14
    mov rbx, [output_ptr]
    mov [rbx], al
    inc qword [output_ptr]

.skip_write_sib:
    inc qword [current_offset]

.no_sib_byte:

    ; 5. Write Displacement (if mod_type > 0)
    mov rax, [mod_type]
    cmp rax, 0
    je .no_disp_byte

    cmp rax, 1
    je .write_disp8

    ; Disp32
    cmp qword [pass_count], 2
    jne .skip_write_disp32

    call check_buffer_overflow
    mov rax, [displacement_val]
    mov rbx, [output_ptr]
    mov [rbx], eax
    add qword [output_ptr], 4

.skip_write_disp32:
    add qword [current_offset], 4
    jmp .no_disp_byte

.write_disp8:
    cmp qword [pass_count], 2
    jne .skip_write_disp8

    call check_buffer_overflow
    mov rax, [displacement_val]
    mov rbx, [output_ptr]
    mov [rbx], al
    inc qword [output_ptr]

.skip_write_disp8:
    inc qword [current_offset]

.no_disp_byte:

.check_immediates:
    ; Check r12 (Flags)
    test r12, 4 ; Imm8
    jnz .parse_imm8
    test r12, 8 ; Imm32
    jnz .parse_imm32

    jmp .assemble_loop

.parse_imm8:
    ; Parse immediate operand
    ; It might be after a comma if there was a ModRM operand
    ; Check if next token is comma?
    ; Simplified: Just call get_token. If it is comma, call again.

    call get_token
    ; If token is comma, read next
    lea rdi, [token_buffer]
    cmp byte [rdi], ','
    jne .do_parse_imm8
    call get_token

.do_parse_imm8:
    call parse_int

    cmp qword [pass_count], 2
    jne .skip_write_imm8

    call check_buffer_overflow
    mov rbx, [output_ptr]
    mov [rbx], al ; Store byte
    inc qword [output_ptr]

.skip_write_imm8:
    inc qword [current_offset]
    jmp .assemble_loop

.parse_imm32:
    call get_token
    ; If token is comma, read next
    lea rdi, [token_buffer]
    cmp byte [rdi], ','
    jne .do_parse_imm32
    call get_token

.do_parse_imm32:
    ; Check if it is a label (symbol)
    ; Try parsing int first. If it returns valid, use it.
    ; But our parse_int is naive.
    ; Let's check first char. If digit or -, int. If char, symbol.
    lea rsi, [token_buffer]
    mov al, [rsi]
    cmp al, '-'
    je .is_int
    cmp al, '0'
    jb .is_symbol
    cmp al, '9'
    ja .is_symbol

.is_int:
    call parse_int
    ; Optimization Check: 0x81 (Imm32) -> 0x83 (Imm8)
    ; Check if opcode is 0x81
    lea rdi, [opcode_buf]
    cmp byte [rdi], 0x81
    jne .write_imm32

    ; Check if value fits in 8 bits (-128 to 127)
    cmp rax, -128
    jl .write_imm32
    cmp rax, 127
    jg .write_imm32

    ; Optimize!
    ; In Pass 2, we must patch the previously written opcode (0x81 -> 0x83)
    cmp qword [pass_count], 2
    jne .skip_patch_opcode

    push rax ; Save Immediate
    push rdi ; Save Opcode Buf ptr

    ; Backtrack output_ptr to find opcode
    mov rbx, [output_ptr]
    sub rbx, 1 ; ModRM (Always present for 0x81)

    ; Check SIB (Bit 8 of r13)
    test r13, 0x100
    jz .opt_no_sib
    sub rbx, 1
.opt_no_sib:

    ; Check Disp
    mov rcx, [mod_type]
    cmp rcx, 1
    je .opt_disp8
    cmp rcx, 2
    je .opt_disp32
    jmp .opt_do_patch

.opt_disp8:
    sub rbx, 1
    jmp .opt_do_patch
.opt_disp32:
    sub rbx, 4

.opt_do_patch:
    sub rbx, 1 ; Opcode byte (0x81)
    mov byte [rbx], 0x83 ; Patch to 0x83

    pop rdi
    pop rax

.skip_patch_opcode:

    ; Write Imm8
    cmp qword [pass_count], 2
    jne .skip_write_opt_imm8

    call check_buffer_overflow
    mov rbx, [output_ptr]
    mov [rbx], al
    inc qword [output_ptr]

.skip_write_opt_imm8:
    inc qword [current_offset]
    jmp .assemble_loop

.is_symbol:
    ; Symbol Reference (Label)
    ; Only resolve in Pass 2
    cmp qword [pass_count], 2
    jne .mock_imm32

    ; Hash symbol
    lea rdi, [token_buffer]
    call strlen
    mov rsi, rax
    lea rdi, [token_buffer]
    call fnv1a_hash

    call find_symbol
    cmp rcx, 0
    je .symbol_not_found

    ; Calculate Relative Offset
    ; Target (rbx) - (Current (current_offset) + 4)
    ; But wait, current_offset is at START of imm32.
    ; So instruction ends at current_offset + 4.
    ; Offset = Target - (current_offset + 4)

    sub rbx, [current_offset]
    sub rbx, 4
    mov rax, rbx
    jmp .write_imm32

.mock_imm32:
    xor rax, rax

.write_imm32:
    cmp qword [pass_count], 2
    jne .skip_write_imm32

    call check_buffer_overflow
    mov rbx, [output_ptr]
    mov [rbx], eax ; Store 4 bytes
    add qword [output_ptr], 4

.skip_write_imm32:
    add qword [current_offset], 4
    jmp .assemble_loop

.symbol_not_found:
    ; Error
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err] ; Reuse err
    mov rdx, 16
    syscall

    ; Print the token that failed
    lea rdi, [token_buffer]
    call strlen
    mov rdx, rax
    lea rsi, [token_buffer]
    mov rax, sys_write
    mov rdi, 1
    syscall

    mov rax, sys_write
    mov rdi, 1
    lea rsi, [newline]
    mov rdx, 1
    syscall

    jmp exit

.pass_done:
    cmp qword [pass_count], 1
    jne .finish

    ; Start Pass 2
    inc qword [pass_count]

    ; Reset Source Ptr (Need to store start_ptr)
    mov rax, [start_ptr]
    mov [source_ptr], rax

    ; Reset Output Ptr (Rewind to after header)
    lea rax, [output_buffer]
    add rax, 8
    mov [output_ptr], rax

    jmp .pass_start

.unknown_token:
    ; DEBUG: Print length of token
    push rax
    lea rdi, [token_buffer]
    call strlen
    mov rdx, rax
    add rdx, '0'
    mov [char_buf], dl
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [char_buf]
    mov rdx, 1
    syscall
    pop rax

    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_unknown]
    mov rdx, 22
    syscall

    ; Print the token that failed
    lea rdi, [token_buffer]
    call strlen
    mov rdx, rax
    lea rsi, [token_buffer]
    mov rax, sys_write
    mov rdi, 1
    syscall

    mov rax, sys_write
    mov rdi, 1
    lea rsi, [newline]
    mov rdx, 1
    syscall

    jmp exit

.finish:
    ; Create Output File
    mov rax, sys_open
    lea rdi, [output_filename]
    mov rsi, O_CREAT + O_WRONLY + O_TRUNC
    mov rdx, S_IRWXU
    syscall

    cmp rax, 0
    jl error_create
    mov [output_fd], rax

    ; Write Buffer to File
    mov rax, sys_write
    mov rdi, [output_fd]
    lea rsi, [output_buffer]
    mov rdx, [output_ptr]
    sub rdx, rsi ; Length = output_ptr - output_buffer
    syscall

    ; Close Output
    mov rax, sys_close
    mov rdi, [output_fd]
    syscall

    ; Success Exit
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_done]
    mov rdx, 16
    syscall

    mov rax, sys_exit
    xor rdi, rdi
    syscall

usage:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_usage]
    mov rdx, 20
    syscall
    jmp exit

error_open:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err_open]
    mov rdx, 19
    syscall
    jmp exit

error_mmap:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err_mmap]
    mov rdx, 19
    syscall
    jmp exit

error_create:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err_create]
    mov rdx, 21
    syscall
    jmp exit

exit:
    mov rax, sys_exit
    xor rdi, rdi ; Correct exit code 0
    syscall

; --- ROUTINES ---

check_buffer_overflow:
    ; Check if output_ptr >= output_buffer + 1048576 - 8 (Safety margin for multibyte writes)
    push rax
    push rbx
    mov rax, [output_ptr]
    lea rbx, [output_buffer]
    add rbx, 1048568
    cmp rax, rbx
    jae .overflow
    pop rbx
    pop rax
    ret
.overflow:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err_out_overflow]
    mov rdx, 27
    syscall
    jmp exit

add_symbol:
    ; Input: rax (hash), rbx (offset)
    ; Output: None
    mov rcx, [symbol_count]
    cmp rcx, 1024
    jge .symbol_overflow

    mov rdx, rcx
    shl rdx, 4 ; * 16 (8 byte hash + 8 byte offset)
    lea rdi, [symbol_table + rdx]
    mov [rdi], rax
    mov [rdi + 8], rbx
    inc qword [symbol_count]
    ret

.symbol_overflow:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err_sym_overflow]
    mov rdx, 26
    syscall
    jmp exit

find_symbol:
    ; Input: rax (hash)
    ; Output: rbx (offset), rcx (found=1/0)
    mov rcx, [symbol_count]
    lea rdi, [symbol_table]
    xor rdx, rdx
.loop_find:
    cmp rdx, rcx
    je .not_found_sym

    cmp [rdi], rax
    je .found_sym

    add rdi, 16
    inc rdx
    jmp .loop_find

.found_sym:
    mov rbx, [rdi + 8]
    mov rcx, 1
    ret

.not_found_sym:
    xor rbx, rbx
    xor rcx, rcx
    ret

try_parse_directive:
    ; Input: token_buffer
    ; Output: rax=1 if handled, 0 if not

    lea rdi, [token_buffer]

    ; Check 'format'
    mov rsi, str_format
    call strcmp
    test rax, rax
    jnz .handle_format

    ; Check 'entry'
    mov rsi, str_entry
    call strcmp
    test rax, rax
    jnz .handle_entry

    ; Check 'segment'
    mov rsi, str_segment
    call strcmp
    test rax, rax
    jnz .handle_segment

    ; Check 'include'
    mov rsi, str_include
    call strcmp
    test rax, rax
    jnz .handle_include

    ; Check 'db'
    mov rsi, str_db
    call strcmp
    test rax, rax
    jnz .handle_db

    ; Check 'rb'
    mov rsi, str_rb
    call strcmp
    test rax, rax
    jnz .handle_rb

    mov rax, 0
    ret

.handle_format:
    ; Ignore arguments for now (e.g. ELF64 executable)
    call get_token
    call get_token ; executable
    mov rax, 1
    ret

.handle_entry:
    ; Ignore argument (start)
    call get_token
    mov rax, 1
    ret

.handle_segment:
    ; Ignore arguments (readable writeable etc)
    ; Just skip tokens until newline? Or strict count?
    ; Simplified: read 2 tokens
    call get_token
    call get_token
    mov rax, 1
    ret

.handle_include:
    ; Ignore argument
    call get_token
    mov rax, 1
    ret

.handle_rb:
    ; Reserve Bytes
    call get_token
    call parse_int ; rax = count

    ; If Pass 2, actually emit zeros?
    ; RB in FASM usually just advances pointer, BSS section.
    ; Our simplified assembler outputs flat binary mapping.
    ; So we should emit zeros.

    cmp qword [pass_count], 2
    jne .skip_write_rb

    push rax
    push rbx
    mov rbx, [output_ptr]
    add rbx, rax
    lea rax, [output_buffer]
    add rax, 1048576
    cmp rbx, rax
    jae .rb_overflow
    pop rbx
    pop rax
    jmp .rb_ok
.rb_overflow:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err_out_overflow]
    mov rdx, 27
    syscall
    jmp exit
.rb_ok:

    mov rcx, rax
    mov rdi, [output_ptr]
    xor al, al
    rep stosb
    mov [output_ptr], rdi

.skip_write_rb:
    add qword [current_offset], rax
    mov rax, 1
    ret

.handle_db:
    ; Define Byte (String or Int)
    ; Only support single string or int for now
    call get_token
    lea rdi, [token_buffer]
    cmp byte [rdi], '"' ; Quote?
    je .db_string
    cmp byte [rdi], "'" ; Quote?
    je .db_string

    ; Int
    call parse_int
    cmp qword [pass_count], 2
    jne .skip_write_db_int

    call check_buffer_overflow
    mov rbx, [output_ptr]
    mov [rbx], al
    inc qword [output_ptr]

.skip_write_db_int:
    inc qword [current_offset]
    mov rax, 1
    ret

.db_string:
    ; Parse String content
    ; token_buffer has the string with quotes included (lexer logic needs check)
    ; Our get_token splits by space. String with space will be split.
    ; TODO: Fix lexer for strings.
    ; For now assume string has no spaces or get_token handles it (it doesn't yet).
    ; We'll implement a simple string copier skipping quotes.

    call strlen
    mov rcx, rax
    sub rcx, 2 ; Remove quotes

    cmp qword [pass_count], 2
    jne .skip_write_db_str

    push rax
    push rbx
    mov rbx, [output_ptr]
    add rbx, rcx
    lea rax, [output_buffer]
    add rax, 1048576
    cmp rbx, rax
    jae .db_str_overflow
    pop rbx
    pop rax
    jmp .db_str_ok
.db_str_overflow:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err_out_overflow]
    mov rdx, 27
    syscall
    jmp exit
.db_str_ok:

    lea rsi, [token_buffer + 1] ; Skip first quote
    mov rdi, [output_ptr]
    rep movsb
    mov [output_ptr], rdi

.skip_write_db_str:
    add qword [current_offset], rcx
    mov rax, 1
    ret

try_parse_structure:
    lea rdi, [token_buffer]

    mov rsi, str_jika
    call strcmp
    test rax, rax
    jnz .handle_jika

    mov rsi, str_selama
    call strcmp
    test rax, rax
    jnz .handle_selama

    mov rsi, str_lain
    call strcmp
    test rax, rax
    jnz .handle_lain

    mov rsi, str_akhir
    call strcmp
    test rax, rax
    jnz .handle_akhir

    mov rsi, str_fungsi
    call strcmp
    test rax, rax
    jnz .handle_fungsi

    mov rsi, str_kembali
    call strcmp
    test rax, rax
    jnz .handle_kembali

    mov rax, 0
    ret

.handle_jika:
    call get_scope_id
    mov r15, rax

    mov rdi, 1 ; IF
    mov rsi, r15
    call push_scope

    call get_token
    lea rdi, [token_buffer]
    call map_condition_inverse
    mov r14, rax

    call get_token ; maka

    lea rdi, [token_buffer]
    mov rsi, r15
    call construct_label_if_else

    mov rdi, r14
    lea rsi, [token_buffer]
    call emit_jcc

    mov rax, 1
    ret

.handle_selama:
    call get_scope_id
    mov r15, rax

    mov rdi, 2 ; WHILE
    mov rsi, r15
    call push_scope

    lea rdi, [token_buffer]
    mov rsi, r15
    call construct_label_while_start
    lea rdi, [token_buffer]
    call define_label

    call get_token
    lea rdi, [token_buffer]
    call map_condition_inverse
    mov r14, rax

    call get_token ; lakukan

    lea rdi, [token_buffer]
    mov rsi, r15
    call construct_label_while_end

    mov rdi, r14
    lea rsi, [token_buffer]
    call emit_jcc

    mov rax, 1
    ret

.handle_lain:
    call peek_scope
    cmp rax, 1
    jne .err_structure
    mov r15, rbx

    lea rdi, [token_buffer]
    mov rsi, r15
    call construct_label_if_end
    lea rsi, [token_buffer]
    call emit_jmp

    lea rdi, [token_buffer]
    mov rsi, r15
    call construct_label_if_else
    lea rdi, [token_buffer]
    call define_label

    call set_scope_else_flag
    mov rax, 1
    ret

.handle_akhir:
    call pop_scope
    cmp rax, 1
    je .akhir_if
    cmp rax, 2
    je .akhir_while
    cmp rax, 3
    je .akhir_func
    jmp .err_structure

.akhir_if:
    cmp rcx, 1
    je .akhir_if_has_else
    lea rdi, [token_buffer]
    mov rsi, rbx
    call construct_label_if_else
    lea rdi, [token_buffer]
    call define_label
    jmp .akhir_done
.akhir_if_has_else:
    lea rdi, [token_buffer]
    mov rsi, rbx
    call construct_label_if_end
    lea rdi, [token_buffer]
    call define_label
    jmp .akhir_done

.akhir_while:
    lea rdi, [token_buffer]
    mov rsi, rbx
    call construct_label_while_start
    lea rsi, [token_buffer]
    call emit_jmp
    lea rdi, [token_buffer]
    mov rsi, rbx
    call construct_label_while_end
    lea rdi, [token_buffer]
    call define_label
    jmp .akhir_done

.akhir_func:
    mov al, 0xC9
    call emit_byte
    mov al, 0xC3
    call emit_byte
    jmp .akhir_done

.akhir_done:
    mov rax, 1
    ret

.handle_fungsi:
    call get_token
    lea rdi, [token_buffer]
    call define_label
    mov rdi, 3
    mov rsi, 0
    call push_scope
    mov al, 0x55
    call emit_byte
    mov al, 0x48
    call emit_byte
    mov al, 0x89
    call emit_byte
    mov al, 0xE5
    call emit_byte
    mov rax, 1
    ret

.handle_kembali:
    mov al, 0xC9
    call emit_byte
    mov al, 0xC3
    call emit_byte
    mov rax, 1
    ret

.err_structure:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err]
    mov rdx, 16
    syscall
    jmp exit

; --- Structure Helpers ---

get_scope_id:
    mov rax, [next_label_id]
    inc qword [next_label_id]
    ret

push_scope:
    ; rdi=Type, rsi=ID
    mov rax, [stack_top]
    lea rbx, [control_stack + rax]
    mov [rbx], rdi
    mov [rbx+8], rsi
    mov qword [rbx+16], 0 ; Flags
    add qword [stack_top], 24
    ret

pop_scope:
    ; Returns rax=Type, rbx=ID, rcx=Flags
    mov rax, [stack_top]
    sub rax, 24
    mov [stack_top], rax
    lea rdx, [control_stack + rax]
    mov rax, [rdx]
    mov rbx, [rdx+8]
    mov rcx, [rdx+16]
    ret

peek_scope:
    mov rax, [stack_top]
    sub rax, 24
    lea rdx, [control_stack + rax]
    mov rax, [rdx]
    mov rbx, [rdx+8]
    mov rcx, [rdx+16]
    ret

set_scope_else_flag:
    mov rax, [stack_top]
    sub rax, 24
    lea rdx, [control_stack + rax]
    mov qword [rdx+16], 1
    ret

emit_byte:
    ; al = byte
    cmp qword [pass_count], 2
    jne .emit_byte_skip
    push rax
    call check_buffer_overflow
    pop rax
    mov rbx, [output_ptr]
    mov [rbx], al
    inc qword [output_ptr]
.emit_byte_skip:
    inc qword [current_offset]
    ret

emit_jcc:
    ; rdi = opcode (e.g. 0x84), rsi = label string
    mov al, 0x0F
    call emit_byte
    mov rax, rdi
    call emit_byte
    ; Rel32
    jmp emit_rel32_label

emit_jmp:
    ; rsi = label string
    mov al, 0xE9
    call emit_byte
    jmp emit_rel32_label

emit_rel32_label:
    ; rsi = label string
    cmp qword [pass_count], 2
    jne .skip_rel32

    push rsi
    mov rdi, rsi
    call strlen
    mov rsi, rax
    pop rdi
    push rdi
    call fnv1a_hash
    call find_symbol
    pop rdi

    cmp rcx, 0
    je .rel32_not_found

    ; Calc offset: Target(rbx) - (Current + 4)
    ; current_offset is updated by emit_byte calls BEFORE this.
    ; So current_offset points to start of rel32.
    ; Instruction ends at current_offset + 4.
    sub rbx, [current_offset]
    sub rbx, 4
    mov rax, rbx
    jmp .write_rel32

.rel32_not_found:
    xor rax, rax

.write_rel32:
    push rax
    call check_buffer_overflow
    pop rax
    mov rbx, [output_ptr]
    mov [rbx], eax
    add qword [output_ptr], 4

.skip_rel32:
    add qword [current_offset], 4
    ret

define_label:
    ; rdi = label string
    cmp qword [pass_count], 1
    jne .def_skip
    push rdi
    call strlen
    mov rsi, rax
    pop rdi
    call fnv1a_hash
    mov rbx, [current_offset]
    call add_symbol
.def_skip:
    ret

map_condition_inverse:
    ; rdi = string (eq, ne...)
    ; Returns opcode (0x85 for eq->jne)
    mov al, [rdi]
    cmp al, 'e' ; eq
    je .cond_eq
    cmp al, 'n' ; ne
    je .cond_ne
    cmp al, 'l' ; lt, le
    je .cond_l
    cmp al, 'g' ; gt, ge
    je .cond_g
    xor rax, rax
    ret
.cond_eq: mov rax, 0x85 ; jne
    ret
.cond_ne: mov rax, 0x84 ; je
    ret
.cond_l:
    cmp byte [rdi+1], 'e'
    je .cond_le
    mov rax, 0x8D ; lt->jge
    ret
.cond_le: mov rax, 0x8F ; le->jg
    ret
.cond_g:
    cmp byte [rdi+1], 'e'
    je .cond_ge
    mov rax, 0x8E ; gt->jle
    ret
.cond_ge: mov rax, 0x8C ; ge->jl
    ret

construct_label_if_else:
    ; rdi=buf, rsi=id
    mov byte [rdi], '.'
    mov byte [rdi+1], 'L'
    mov byte [rdi+2], 'I'
    mov byte [rdi+3], 'F'
    add rdi, 4
    call int_to_str_buf
    mov byte [rdi], 'E'
    mov byte [rdi+1], 'L'
    mov byte [rdi+2], 'S'
    mov byte [rdi+3], 'E'
    mov byte [rdi+4], 0
    ret

construct_label_if_end:
    mov byte [rdi], '.'
    mov byte [rdi+1], 'L'
    mov byte [rdi+2], 'I'
    mov byte [rdi+3], 'F'
    add rdi, 4
    call int_to_str_buf
    mov byte [rdi], 'E'
    mov byte [rdi+1], 'N'
    mov byte [rdi+2], 'D'
    mov byte [rdi+3], 0
    ret

construct_label_while_start:
    mov byte [rdi], '.'
    mov byte [rdi+1], 'L'
    mov byte [rdi+2], 'W'
    mov byte [rdi+3], 'S'
    add rdi, 4
    call int_to_str_buf
    mov byte [rdi], 0
    ret

construct_label_while_end:
    mov byte [rdi], '.'
    mov byte [rdi+1], 'L'
    mov byte [rdi+2], 'W'
    mov byte [rdi+3], 'E'
    add rdi, 4
    call int_to_str_buf
    mov byte [rdi], 0
    ret

int_to_str_buf:
    ; rsi = int, rdi = buffer
    ; Writes int to buffer, advances rdi
    push rbx
    push rcx
    push rdx

    mov rax, rsi
    mov rcx, 10
    mov rbx, rdi ; Start

    ; If 0
    cmp rax, 0
    jne .its_loop
    mov byte [rdi], '0'
    inc rdi
    pop rdx
    pop rcx
    pop rbx
    ret

.its_loop:
    xor rdx, rdx
    div rcx
    add dl, '0'
    mov [rdi], dl
    inc rdi
    cmp rax, 0
    jne .its_loop

    ; Reverse
    mov rcx, rdi
    dec rcx ; End
    mov rsi, rbx ; Start

.rev_loop:
    cmp rsi, rcx
    jae .rev_done
    mov al, [rsi]
    mov dl, [rcx]
    mov [rsi], dl
    mov [rcx], al
    inc rsi
    dec rcx
    jmp .rev_loop

.rev_done:
    pop rdx
    pop rcx
    pop rbx
    ret

try_parse_label:
    ; Input: token_buffer, rax (token length)
    ; Output: rax=1 if label handled, 0 if not

    lea rdi, [token_buffer]
    mov rcx, rax ; length

    ; Check if ends with ':'
    cmp byte [rdi + rcx - 1], ':'
    jne .not_a_label

    ; Is Label Definition
    ; Pass 1: Add to symbol table
    cmp qword [pass_count], 1
    jne .label_handled

    ; Remove colon
    mov byte [rdi + rcx - 1], 0
    dec rcx

    ; Hash
    mov rsi, rcx
    push rdi
    call fnv1a_hash
    pop rdi

    ; Add Symbol (Offset = current_offset)
    mov rbx, [current_offset]
    call add_symbol

.label_handled:
    mov rax, 1
    ret

.not_a_label:
    mov rax, 0
    ret

get_token:
    ; Output: token_buffer filled, rax = length
    ; If EOF, rax = 0

    xor rcx, rcx ; token length
    lea rdi, [token_buffer]

.skip_whitespace:
    mov rsi, [source_ptr]
    cmp rsi, [source_end]
    jae .eof

    mov al, [rsi]
    inc qword [source_ptr]

    ; Check whitespace
    cmp al, ' '
    je .skip_whitespace
    cmp al, 9 ; tab
    je .skip_whitespace
    cmp al, 10 ; newline
    je .skip_whitespace
    cmp al, 13 ; CR
    je .skip_whitespace

    ; Check comment
    cmp al, ';'
    je .skip_comment

    ; Found start of token
    jmp .check_token_start

.skip_comment:
    mov rsi, [source_ptr]
    cmp rsi, [source_end]
    jae .eof

    mov al, [rsi]
    inc qword [source_ptr]

    cmp al, 10 ; newline ends comment
    je .skip_whitespace
    jmp .skip_comment

    ; Check for string start
    cmp al, '"'
    je .read_string_double
    cmp al, "'"
    je .read_string_single

.check_token_start:
    ; Check for string start
    cmp al, '"'
    je .read_string_double
    cmp al, "'"
    je .read_string_single
    jmp .read_token_char

.read_token_loop:
    mov rsi, [source_ptr]
    cmp rsi, [source_end]
    jae .token_done

    mov al, [rsi]
    ; Check delimiters
    cmp al, ' '
    je .token_done
    cmp al, 9
    je .token_done
    cmp al, 10
    je .token_done
    cmp al, 13
    je .token_done
    cmp al, ';'
    je .token_done_rewind ; Rewind so next call sees comment
    cmp al, ','
    je .token_single_char ; Comma is a separate token?

    inc qword [source_ptr]

.read_token_char:
    mov [rdi + rcx], al
    inc rcx
    cmp rcx, 255
    jge .token_done ; safety
    jmp .read_token_loop

.read_string_double:
    ; Consume initial quote
    inc qword [source_ptr]
    mov byte [rdi + rcx], '"'
    inc rcx

.read_string_double_loop:
    mov rsi, [source_ptr]
    cmp rsi, [source_end]
    jae .token_done

    mov al, [rsi]
    inc qword [source_ptr]

    mov [rdi + rcx], al
    inc rcx

    cmp al, '"'
    je .token_done

    cmp rcx, 255
    jge .token_done
    jmp .read_string_double_loop

.read_string_single:
    ; Consume initial quote
    inc qword [source_ptr]
    mov byte [rdi + rcx], "'"
    inc rcx

.read_string_single_loop:
    mov rsi, [source_ptr]
    cmp rsi, [source_end]
    jae .token_done

    mov al, [rsi]
    inc qword [source_ptr]

    mov [rdi + rcx], al
    inc rcx

    cmp al, "'"
    je .token_done

    cmp rcx, 255
    jge .token_done
    jmp .read_string_single_loop

.token_done_rewind:
    ; We hit a char that shouldn't be consumed (like ';')
    ; source_ptr is NOT incremented for it yet (in read_token_loop check)
    jmp .token_done

.token_single_char:
    ; If we hit a comma, and we have accumulated token, stop.
    ; If we haven't (rcx=0), then consume comma as the token.
    cmp rcx, 0
    jne .token_done ; Return current token, leave comma for next

    ; Emit comma as token
    inc qword [source_ptr]
    mov [rdi], al
    mov rcx, 1
    jmp .token_done

.token_done:
    mov byte [rdi + rcx], 0 ; null terminate
    mov rax, rcx
    ret

.eof:
    mov rax, 0
    ret

parse_register:
    ; Input: token_buffer
    ; Output: rax = register ID (0-15), rdx = 1 if memory bracket found
    xor rdx, rdx

    lea rdi, [token_buffer]
    cmp byte [rdi], '['
    jne .check_reg_char

    ; Memory Operand found
    mov rdx, 1
    inc rdi ; Skip '['
    ; We need to trim ']' at end
    ; This modifies token_buffer, but that is fine.

    ; Find end
    push rdi
    call strlen
    pop rdi
    mov rcx, rax

    cmp byte [rdi + rcx - 1], ']'
    jne .unknown_reg

    mov byte [rdi + rcx - 1], 0 ; Null terminate

    ; Now rdi points to register string inside brackets
    ; Move rdi to token_buffer (or adjust logic below to use rdi)
    ; parse_register logic below uses [token_buffer] and [rdi].
    ; Let's copy content back to start of token_buffer?
    ; Or just adjust rdi.
    ; Below logic uses [rdi] which is initialized to [token_buffer].
    ; So we just need to update rdi?
    ; Wait, the labels below use offsets from rdi.
    ; So yes, updating rdi is enough.

    ; Displacement Logic
    push rdi
    call find_plus_minus
    pop rdi

    cmp rax, 0
    je .no_disp

    ; Found displacement at [rax]
    mov bl, [rax] ; Save sign (+ or -)
    mov byte [rax], 0 ; Terminate register string

    inc rax ; Point to digits

    push rdi ; Save register string ptr
    push rbx ; Save sign

    ; Parse int from rax
    ; We need a parse_int that takes RSI as input.
    ; My parse_int takes token_buffer hardcoded.
    ; I need to update parse_int to use RSI.
    ; Or copy to temp buffer? RSI is better.

    mov rsi, rax
    call parse_int_rsi ; New/Modified function

    pop rbx ; Restore sign
    pop rdi ; Restore register string ptr

    cmp bl, '-'
    jne .disp_pos
    neg rax
.disp_pos:
    mov [displacement_val], rax

    ; Determine Mod Type
    ; Check if fits in Disp8 (-128 to 127)
    cmp rax, -128
    jl .mod_disp32
    cmp rax, 127
    jg .mod_disp32

    mov qword [mod_type], 1 ; Mod01 (Disp8)
    jmp .check_reg_char

.mod_disp32:
    mov qword [mod_type], 2 ; Mod10 (Disp32)
    jmp .check_reg_char

.no_disp:
    mov qword [mod_type], 0
    mov qword [displacement_val], 0

.check_reg_char:
    cmp byte [rdi], 'r'
    jne .unknown_reg

    ; Check 2nd char
    mov al, [rdi+1]

    cmp al, 'a' ; rax
    je .reg_rax
    cmp al, 'c' ; rcx
    je .reg_rcx
    cmp al, 'd' ; rdx, rdi
    je .reg_d_check
    cmp al, 'b' ; rbx, rbp
    je .reg_b_check
    cmp al, 's' ; rsi, rsp
    je .reg_s_check

    ; Check digit for r8-r15
    cmp al, '0'
    jb .unknown_reg
    cmp al, '9'
    ja .unknown_reg
    jmp .reg_num_check

.reg_d_check:
    cmp byte [rdi+2], 'x' ; rdx
    je .reg_rdx
    cmp byte [rdi+2], 'i' ; rdi
    je .reg_rdi
    jmp .unknown_reg

.reg_b_check:
    cmp byte [rdi+2], 'x' ; rbx
    je .reg_rbx
    cmp byte [rdi+2], 'p' ; rbp
    je .reg_rbp
    jmp .unknown_reg

.reg_s_check:
    cmp byte [rdi+2], 'i' ; rsi
    je .reg_rsi
    cmp byte [rdi+2], 'p' ; rsp
    je .reg_rsp
    jmp .unknown_reg

.reg_rax: mov rax, 0
    ret
.reg_rcx: mov rax, 1
    ret
.reg_rdx: mov rax, 2
    ret
.reg_rbx: mov rax, 3
    ret
.reg_rsp: mov rax, 4
    ret
.reg_rbp: mov rax, 5
    ret
.reg_rsi: mov rax, 6
    ret
.reg_rdi: mov rax, 7
    ret

.reg_num_check:
    ; It is a digit. Parse int starting from index 1.
    ; Need to adjust rsi to point to [rdi+1]
    ; rdi points to token_buffer (or memory operand start)
    push rsi
    lea rsi, [rdi+1] ; rdi + 1
    xor rax, rax
    xor rcx, rcx
.parse_r_loop:
    mov cl, [rsi]
    cmp cl, '0'
    jb .parse_r_done
    cmp cl, '9'
    ja .parse_r_done
    sub cl, '0'
    imul rax, 10
    add rax, rcx
    inc rsi
    jmp .parse_r_loop
.parse_r_done:
    pop rsi

    ; RAX now has register number (e.g. 8, 12)
    ; Range check? 8-15
    ; Actually 0-15 is fine if user writes r0...r7 (not standard but ok)
    ; DEBUG
    ; push rax
    ; add al, '0'
    ; call print_char
    ; pop rax
    ret

.unknown_reg:
    ; Fail for now (return 0 or crash safely)
    mov rax, -1
    ret

find_plus_minus:
    ; Input: rdi (string)
    ; Output: rax (pointer to char or 0)
    mov rax, rdi
.fpm_loop:
    mov cl, [rax]
    cmp cl, 0
    je .fpm_not_found
    cmp cl, '+'
    je .fpm_found
    cmp cl, '-'
    je .fpm_found
    inc rax
    jmp .fpm_loop
.fpm_found:
    ret
.fpm_not_found:
    xor rax, rax
    ret

parse_int:
    ; Input: token_buffer
    ; Output: rax = integer value
    lea rsi, [token_buffer]
    jmp parse_int_rsi

parse_int_rsi:
    ; Input: rsi (string ptr)
    ; Output: rax = integer value
    xor rax, rax
    xor rcx, rcx
    xor r8, r8   ; Sign (0=+, 1=-)
    mov r9, 10   ; Base

    ; Check Sign
    cmp byte [rsi], '-'
    jne .check_hex
    mov r8, 1
    inc rsi

.check_hex:
    cmp byte [rsi], '0'
    jne .parse_int_loop
    mov r10b, [rsi+1]
    cmp r10b, 'x'
    je .is_hex
    cmp r10b, 'X'
    je .is_hex
    jmp .parse_int_loop

.is_hex:
    mov r9, 16
    add rsi, 2
    xor rax, rax

.parse_int_loop:
    mov cl, [rsi]
    cmp cl, 0
    je .parse_int_done

    ; Convert char to val
    cmp cl, '0'
    jb .invalid_digit
    cmp cl, '9'
    jbe .digit_09

    cmp cl, 'A'
    jb .invalid_digit
    cmp cl, 'F'
    jbe .digit_AF

    cmp cl, 'a'
    jb .invalid_digit
    cmp cl, 'f'
    jbe .digit_af

    jmp .invalid_digit

.digit_09:
    sub cl, '0'
    jmp .check_base

.digit_AF:
    sub cl, 'A'
    add cl, 10
    jmp .check_base

.digit_af:
    sub cl, 'a'
    add cl, 10
    jmp .check_base

.check_base:
    movzx rdx, cl
    cmp rdx, r9
    jae .invalid_digit

    imul rax, r9
    add rax, rdx

    inc rsi
    jmp .parse_int_loop

.parse_int_done:
    cmp r8, 1
    jne .ret
    neg rax
.ret:
    ret

.invalid_digit:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err]
    mov rdx, 16
    syscall

    lea rsi, [token_buffer]
    mov rdi, rsi
    call strlen
    mov rdx, rax
    mov rax, sys_write
    mov rdi, 1
    syscall

    mov rax, sys_write
    mov rdi, 1
    lea rsi, [newline]
    mov rdx, 1
    syscall

    jmp exit

strcmp:
    ; Input: rdi (str1), rsi (str2)
    ; Output: rax (1 if equal, 0 if not)
    push rdi
    push rsi
.loop:
    mov al, [rdi]
    mov bl, [rsi]
    cmp al, bl
    jne .not_equal
    cmp al, 0
    je .equal
    inc rdi
    inc rsi
    jmp .loop
.not_equal:
    pop rsi
    pop rdi
    xor rax, rax
    ret
.equal:
    pop rsi
    pop rdi
    mov rax, 1
    ret

strlen:
    ; Input: rdi (str)
    ; Output: rax (len)
    xor rax, rax
.loop:
    cmp byte [rdi + rax], 0
    je .done
    inc rax
    jmp .loop
.done:
    ret

fnv1a_hash:
    ; Input: rdi (ptr to string), rsi (length)
    ; Output: rax (hash)
    mov rax, 0xcbf29ce484222325
    mov r8, 0x100000001b3
    xor rcx, rcx
.loop:
    cmp rcx, rsi
    je .done
    xor r9, r9
    mov r9b, [rdi + rcx]
    xor rax, r9
    mul r8
    inc rcx
    jmp .loop
.done:
    ret

lookup_instruction:
    ; Input: rax (hash)
    ; Output: rdi (ptr to metadata) or 0 if not found

    push rbx
    mov rbx, rax

    xor rdx, rdx
    mov rcx, VZOEL_TABLE_SIZE
    div rcx

    mov rcx, rdx ; index
    mov rsi, rdx ; start index

.probe:
    mov r8, [vzoel_table_keys + rcx*8]
    cmp r8, 0
    je .not_found

    cmp r8, rbx
    je .found

    inc rcx
    and rcx, VZOEL_TABLE_SIZE - 1

    cmp rcx, rsi
    je .not_found
    jmp .probe

.found:
    mov rdi, [vzoel_table_values + rcx*8]
    pop rbx
    ret

.not_found:
    xor rdi, rdi
    pop rbx
    ret

; --- DATA ---
segment readable writeable
input_filename dq 0
input_fd dq 0
input_size dq 0
source_ptr dq 0
start_ptr dq 0
source_end dq 0
output_ptr dq 0
output_fd dq 0

msg_d1 db "1", 10, 0
msg_d2 db "2", 10, 0
msg_d3 db "3", 10, 0
msg_d4 db "4", 10, 0
msg_usage db "Usage: asm.fox <in>", 10, 0
msg_err db "Error detected.", 10, 0
msg_err_open db "Error: Cannot Open.", 10, 0
msg_err_mmap db "Error: Cannot Mmap.", 10, 0
msg_err_create db "Error: Cannot Create.", 10, 0
msg_unknown db "Error: Unknown token: ", 0
msg_err_sym_overflow db "Error: Symbol Table Full.", 10, 0
msg_err_out_overflow db "Error: Output Buffer Full.", 10, 0
msg_done db "Done. out.morph", 10, 0
char_buf db 0
newline db 10, 0
output_filename db "out.morph", 0

str_format db "format", 0
str_entry db "entry", 0
str_segment db "segment", 0
str_include db "include", 0
str_db db "db", 0
str_rb db "rb", 0

stat_buf:
    rb 144

str_jika db "jika", 0
str_maka db "maka", 0
str_lain db "lain", 0
str_akhir db "akhir", 0
str_selama db "selama", 0
str_lakukan db "lakukan", 0
str_fungsi db "fungsi", 0
str_kembali db "kembali", 0

token_buffer: rb 256
symbol_table: rb 16384 ; Symbol Table (Hash, Offset) * 1024 entries
symbol_count: dq 0
pass_count: dq 0
current_offset: dq 0
opcode_buf: rb 4
opcode_len: dq 0
displacement_val: dq 0
mod_type: dq 0 ; 0=Mod00, 1=Mod01(Disp8), 2=Mod10(Disp32)

control_stack: rb 16384 ; 1024 entries * 16 bytes (Type, ID)
stack_top: dq 0
next_label_id: dq 0

include '../brainlib/vzoel_table.fox'

output_buffer: rb 1048576 ; 1MB
