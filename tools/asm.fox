format ELF64 executable
entry start

; --- CONSTANTS ---
sys_read    = 0
sys_write   = 1
sys_open    = 2
sys_close   = 3
sys_fstat   = 5
sys_mmap    = 9
sys_exit    = 60

O_RDONLY    = 0
PROT_READ   = 1
MAP_PRIVATE = 2

; --- CODE ---
start:
    ; --- ENCODING TEST ---
    ; We will hardcode a test case:
    ; Instruction: mov.r64.r64 (Found via hash)
    ; Operand 1: rax
    ; Operand 2: rbx
    ; Expected Output: 48 89 D8 (REX.W + 89 + ModRM(C0 | src=3(rbx) | dst=0(rax)))
    ; Wait, modrm=rm,reg means DST=RM, SRC=REG.
    ; mov rax, rbx -> DST=rax, SRC=rbx.
    ; ModRM(11, 3, 0) -> C0 | 18 | 0 = D8. Correct.

    ; Setup for test
    ; 1. Lookup "mov.r64.r64"
    lea rdi, [test_mnemonic]
    call strlen
    mov rsi, rax
    lea rdi, [test_mnemonic]
    call fnv1a_hash
    call lookup_instruction

    cmp rdi, 0
    je .fail_lookup

    mov [current_instr_ptr], rdi

    ; 2. Parse Operands "rax", "rbx"
    lea rsi, [test_op1]
    call parse_register
    mov [op1_reg], al

    lea rsi, [test_op2]
    call parse_register
    mov [op2_reg], al

    ; 3. Encode
    call encode_instruction

    ; 4. Print Output Hex
    mov rsi, output_buffer
    mov rcx, [output_len]
    call print_hex

    mov rax, sys_write
    mov rdi, 1
    lea rsi, [newline]
    mov rdx, 1
    syscall

    jmp .continue_main

.fail_lookup:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_not_found]
    mov rdx, 11
    syscall
    jmp exit

.continue_main:
    ; --- ORIGINAL LOGIC ---
    pop rcx
    cmp rcx, 2
    jl usage

    pop rdi
    pop rdi
    mov [input_filename], rdi

    ; Open
    mov rax, sys_open
    mov rdi, [input_filename]
    mov rsi, O_RDONLY
    mov rdx, 0
    syscall

    cmp rax, 0
    jl error_open
    mov [input_fd], rax

    ; Fstat
    mov rax, sys_fstat
    mov rdi, [input_fd]
    lea rsi, [stat_buf]
    syscall

    mov rax, [stat_buf + 48]
    mov [input_size], rax

    ; Mmap
    mov rax, sys_mmap
    mov rdi, 0
    mov rsi, [input_size]
    mov rdx, PROT_READ
    mov r10, MAP_PRIVATE
    mov r8, [input_fd]
    mov r9, 0
    syscall

    cmp rax, -1
    je error_mmap
    mov [source_ptr], rax

    ; Exit
    mov rax, sys_exit
    xor rdi, rdi
    syscall

usage:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_usage]
    mov rdx, 20
    syscall
    jmp exit

error_open:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err]
    mov rdx, 16
    syscall
    jmp exit

error_mmap:
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [msg_err]
    mov rdx, 16
    syscall
    jmp exit

exit:
    mov rax, sys_exit
    mov rdi, 1
    syscall

; --- ROUTINES ---

strlen:
    xor rax, rax
.loop:
    cmp byte [rdi + rax], 0
    je .done
    inc rax
    jmp .loop
.done:
    ret

fnv1a_hash:
    mov rax, 0xcbf29ce484222325
    mov r8, 0x100000001b3
    xor rcx, rcx
.loop:
    cmp rcx, rsi
    je .done
    xor r9, r9
    mov r9b, [rdi + rcx]
    xor rax, r9
    mul r8
    inc rcx
    jmp .loop
.done:
    ret

lookup_instruction:
    push rbx
    mov rbx, rax
    xor rdx, rdx
    mov rcx, VZOEL_TABLE_SIZE
    div rcx
    mov rcx, rdx
    mov rsi, rdx
.probe:
    mov r8, [vzoel_table_keys + rcx*8]
    cmp r8, 0
    je .not_found
    cmp r8, rbx
    je .found
    inc rcx
    and rcx, VZOEL_TABLE_SIZE - 1
    cmp rcx, rsi
    je .not_found
    jmp .probe
.found:
    mov rdi, [vzoel_table_values + rcx*8]
    pop rbx
    ret
.not_found:
    xor rdi, rdi
    pop rbx
    ret

parse_register:
    ; Input: rsi (string ptr e.g. "rax")
    ; Output: al (id 0-15), ah (success 1/0)
    ; Simple hash check or string cmp? String cmp is safer for now.

    ; rsi points to string.
    ; We can optimize later. For now, brute force check common regs.

    cmp dword [rsi], 0x786172 ; 'rax' (little endian: 'r' 'a' 'x' 0) -> 0x786172 is wrong.
    ; 'r' = 0x72, 'a' = 0x61, 'x' = 0x78
    ; "rax" = 0x786172

    ; Helper macro for checking
    ; rsi[0] is always 'r' (0x72) or 'e' or ... assume 64-bit 'r'

    mov eax, [rsi]
    and eax, 0xFFFFFF ; Take first 3 bytes

    cmp eax, 0x786172 ; "rax"
    je .is_rax
    cmp eax, 0x786272 ; "rbx"
    je .is_rbx
    cmp eax, 0x786372 ; "rcx"
    je .is_rcx
    cmp eax, 0x786472 ; "rdx"
    je .is_rdx

    ; More checks... skipping for POC (Proof of Concept)
    ; Default to 0 (error)
    xor ax, ax
    ret

.is_rax: mov al, 0
         mov ah, 1
         ret
.is_rcx: mov al, 1
         mov ah, 1
         ret
.is_rdx: mov al, 2
         mov ah, 1
         ret
.is_rbx: mov al, 3
         mov ah, 1
         ret

encode_instruction:
    ; Uses: [current_instr_ptr], [op1_reg], [op2_reg]
    ; Output: Writes to output_buffer

    mov rdi, [current_instr_ptr]

    ; Skip mnemonic string
    call strlen
    add rdi, rax
    inc rdi ; Skip null

    ; Read Flags
    mov al, [rdi]
    inc rdi
    mov [enc_flags], al

    ; Read Opcode Len
    mov al, [rdi]
    inc rdi
    mov [enc_op_len], al

    ; Read Opcode Bytes
    mov eax, [rdi] ; Read 3 bytes (actually 4 but we care about 3)
    mov [enc_op_bytes], eax
    add rdi, 3

    ; Read ModRM Type
    mov al, [rdi]
    mov [enc_modrm_type], al

    ; --- EMIT ---
    lea rsi, [output_buffer]
    xor rcx, rcx

    ; 1. REX Prefix
    ; Check if REX.W needed (Flag bit 0)
    test byte [enc_flags], 1
    jz .no_rex

    mov byte [rsi + rcx], 0x48 ; REX.W
    inc rcx

.no_rex:
    ; 2. Opcode
    movzx rdx, byte [enc_op_len]
    mov eax, [enc_op_bytes]

    ; Write opcode bytes
    ; Assumes len is 1 for now (POC)
    mov [rsi + rcx], al
    inc rcx

    ; 3. ModRM
    ; Type 1 = rm,reg (DST=RM, SRC=REG)
    ; mov rax, rbx -> DST=RAX(0), SRC=RBX(3)
    ; Mod = 11 (Register Mode)
    ; Reg = SRC (3)
    ; RM = DST (0)
    ; Byte = 11 011 000 = C0 | 18 | 0 = D8

    cmp byte [enc_modrm_type], 1
    jne .done

    mov al, 0xC0 ; Mod=11

    mov bl, [op2_reg] ; Src
    shl bl, 3
    or al, bl

    mov bl, [op1_reg] ; Dst
    or al, bl

    mov [rsi + rcx], al
    inc rcx

.done:
    mov [output_len], rcx
    ret

print_hex:
    ; Input: rsi (buffer), rcx (len)
    mov r8, rcx
    xor r9, r9
.hex_loop:
    cmp r9, r8
    je .hex_done

    mov al, [rsi + r9]

    ; High nibble
    mov bl, al
    shr bl, 4
    call print_nibble

    ; Low nibble
    mov bl, al
    and bl, 0x0F
    call print_nibble

    ; Space
    push rsi
    push rdx
    push rcx
    push rax
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [space_char]
    mov rdx, 1
    syscall
    pop rax
    pop rcx
    pop rdx
    pop rsi

    inc r9
    jmp .hex_loop
.hex_done:
    ret

print_nibble:
    cmp bl, 9
    jg .letter
    add bl, '0'
    jmp .print
.letter:
    add bl, 'A' - 10
.print:
    mov [nibble_char], bl
    push rsi
    push rdx
    push rcx
    push rax
    mov rax, sys_write
    mov rdi, 1
    lea rsi, [nibble_char]
    mov rdx, 1
    syscall
    pop rax
    pop rcx
    pop rdx
    pop rsi
    ret

; --- DATA ---
input_filename dq 0
input_fd dq 0
input_size dq 0
source_ptr dq 0
current_instr_ptr dq 0
op1_reg db 0
op2_reg db 0
enc_flags db 0
enc_op_len db 0
enc_op_bytes dd 0
enc_modrm_type db 0
output_len dq 0

output_buffer rb 16

msg_usage db "Usage: asm.fox <in>", 10, 0
msg_err db "Error detected.", 10, 0
msg_not_found db "Not Found.", 10, 0
newline db 10, 0
space_char db ' ', 0
nibble_char db 0, 0

test_mnemonic db "mov.r64.r64", 0
test_op1 db "rax", 0
test_op2 db "rbx", 0

stat_buf:
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
db 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0

include '../brainlib/vzoel_table.fox'
