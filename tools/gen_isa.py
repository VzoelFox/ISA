#!/usr/bin/env python3
import os
import glob
import struct

# Configuration
BRAINLIB_DIR = "brainlib"
OUTPUT_FILE = os.path.join(BRAINLIB_DIR, "vzoel_table.fox")
TABLE_SIZE = 2048 # Power of 2, plenty of space

def fnv1a_64(string):
    FNV_OFFSET_BASIS = 0xcbf29ce484222325
    FNV_PRIME = 0x100000001b3
    h = FNV_OFFSET_BASIS
    for char in string:
        byte = ord(char)
        h ^= byte
        h = (h * FNV_PRIME) & 0xffffffffffffffff
    return h

def parse_vzoel():
    instructions = []
    seen_mnemonics = set()
    vzoel_files = glob.glob(os.path.join(BRAINLIB_DIR, "*.vzoel"))

    for filepath in vzoel_files:
        with open(filepath, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith(';'): continue

                # Extract comment/hint
                comment = ""
                if ';' in line:
                    parts = line.split(';', 1)
                    line = parts[0].strip()
                    comment = parts[1].strip()

                parts = line.split()
                if not parts: continue

                mnemonic = parts[0]

                if mnemonic in seen_mnemonics:
                    continue
                seen_mnemonics.add(mnemonic)

                # Parse Properties
                props = {
                    'rex': '',
                    'opcode': [],
                    'modrm': '',
                    'reg_in_op': False
                }

                for p in parts[1:]:
                    if '=' in p:
                        k, v = p.split('=', 1)
                        if k == 'opcode':
                            props['opcode'] = [int(x, 16) for x in v.split(',')]
                        elif k == 'modrm':
                            props['modrm'] = v
                        elif k == 'rex':
                            props['rex'] = v
                    elif p == 'reg_in_op':
                        props['reg_in_op'] = True

                instructions.append({
                    'mnemonic': mnemonic,
                    'props': props,
                    'comment': comment
                })
    return instructions

def generate_table(instructions):
    keys = [0] * TABLE_SIZE
    values = ["0"] * TABLE_SIZE # Pointers (labels)

    collisions = 0

    for instr in instructions:
        name = instr['mnemonic']
        h = fnv1a_64(name)

        idx = h % TABLE_SIZE
        original_idx = idx

        while keys[idx] != 0:
            collisions += 1
            idx = (idx + 1) % TABLE_SIZE
            if idx == original_idx:
                raise Exception("Hash table full!")

        keys[idx] = h
        # Create a label name from mnemonic (sanitize it)
        label_safe = name.replace('.', '_').replace('[', '').replace(']', '').replace('*', 'mul')
        values[idx] = f"vzoel_entry_{label_safe}"
        instr['label'] = values[idx]
        instr['hash'] = h

    return keys, values

def write_asm(keys, values, instructions):
    with open(OUTPUT_FILE, 'w') as f:
        f.write("; Generated by tools/gen_isa.py\n")
        f.write("; VZOEL ISA Hash Table (FNV-1a 64-bit, Linear Probing)\n\n")

        f.write(f"VZOEL_TABLE_SIZE = {TABLE_SIZE}\n\n")

        f.write("segment readable writeable\n\n")

        f.write("align 8\n")
        f.write("vzoel_table_keys:\n")
        # Write keys in chunks for readability
        for i in range(0, len(keys), 4):
            chunk = [f"0x{k:016x}" for k in keys[i:i+4]]
            f.write(f"    dq {', '.join(chunk)}\n")

        f.write("\nalign 8\n")
        f.write("vzoel_table_values:\n")
        for i in range(0, len(values), 4):
            chunk = values[i:i+4]
            f.write(f"    dq {', '.join(chunk)}\n")

        f.write("\n; --- Instruction Metadata ---\n")

        # Sort instructions by label for nicer output order
        instructions.sort(key=lambda x: x['label'])

        for instr in instructions:
            f.write(f"\n{instr['label']}:\n")

            # 1. Mnemonic String (Null Terminated)
            f.write(f"    db '{instr['mnemonic']}', 0\n")

            # 2. Encoding Info (Fixed Size or Flags)
            # Structure:
            # Offset 0: Mnemonic String...
            # ...
            # Offset N: Flags (1 byte)
            # Offset N+1: Opcode Len (1 byte)
            # Offset N+2: Opcode Bytes (3 bytes max)
            # Offset N+5: ModRM Info (1 byte)

            # We can't use fixed offset from label easily unless we pad string.
            # OR we store pointer to info? No, simpler to just have fixed fields AFTER the string?
            # String length is variable. Parser skips it.

            p = instr['props']

            # Encode Flags: bit 0: REX.W
            flags = 0
            if p['rex'] == 'W': flags |= 1
            if p['reg_in_op']: flags |= 2

            f.write(f"    db {flags} ; Flags (1=REX.W, 2=RegInOp)\n")

            # Opcode
            op_len = len(p['opcode'])
            f.write(f"    db {op_len} ; Opcode Len\n")

            op_bytes = p['opcode'] + [0]*(3-len(p['opcode']))
            f.write(f"    db {', '.join(map(str, op_bytes))} ; Opcode Bytes (Max 3)\n")

            # ModRM Info
            # 0: None, 1: rm,reg, 2: reg,rm, 3: reg,mem, 4: mem,reg
            modrm_code = 0
            m = p['modrm']
            if m == 'rm,reg': modrm_code = 1
            elif m == 'reg,rm': modrm_code = 2
            elif m == 'reg,mem': modrm_code = 3
            elif m == 'mem,reg': modrm_code = 4
            # Simplified for now. '0' '7' etc handled as raw?
            # Let's just store specific codes for register-register mov first.

            f.write(f"    db {modrm_code} ; ModRM Type (1=rm,reg)\n")

            if instr['comment']:
                f.write(f"    ; {instr['comment']}\n")

        print(f"Generated {OUTPUT_FILE} with {len(instructions)} entries.")

if __name__ == "__main__":
    instrs = parse_vzoel()
    k, v = generate_table(instrs)
    write_asm(k, v, instrs)
